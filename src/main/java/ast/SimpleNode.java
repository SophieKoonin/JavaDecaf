package ast;
/*
 * Original code from JavaCC (see copyright notice).
 * Modified by Sophie Koonin 2015. Javadoc comments are mine, even where methods were not
 * implemented by me.
 *
 * Copyright (c) 2006, Sun Microsystems, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     * Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the Sun Microsystems, Inc. nor the names of its
 *       contributors may be used to endorse or promote products derived from
 *       this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */


/* Generated By:JJTree: Do not edit this line. SimpleNode.java */
/* JJT: 0.3pre1 */

/**
 * The superclass of all AST nodes. Contains logic for processing most nodes.
 */

import parser.*;

import java.io.PrintWriter;

public class SimpleNode implements Node {
    /**
     * The parent node of this node
     */
    protected Node parent;
    /**
     * All child nodes belonging to this node
     */
    protected Node[] children;
    /**
     * The ID of this node
     */
    protected int id;
    /**
     * The parser in use
     */
    protected JDCParser parser;

    /**
     * Constructor with ID. This is not in use by the main parser class.
     * @param i the ID of the node.
     */
    public SimpleNode(int i) {
        id = i;
    }

    /**
     * Constructor with parser - this is the one in use.
     * Should not be called manually - called automatically by parser.JDCParser.
      * @param p the parser
     * @param i the ID of the node (automatic)
     */
    public SimpleNode(JDCParser p, int i) {
        id = i;
        parser = p;
    }

    /**
     * @see Node
     */
    public void jjtOpen() {
    }

    /**
     * @see Node
     */
    public void jjtClose() {
    }

    /**
     * @see Node
     */
    public void jjtSetParent(Node n) { parent = n; }

    /**
     * @see Node
     */
    public Node jjtGetParent() { return parent; }

    /**
     * @see Node
     */
    public void jjtAddChild(Node n, int i) {
        if (children == null) {
            children = new Node[i + 1];
        } else if (i >= children.length) {
            Node c[] = new Node[i + 1];
            System.arraycopy(children, 0, c, 0, children.length);
            children = c;
        }
        children[i] = n;
    }

    /**
     * @see Node
     */
    public Node jjtGetChild(int i) {
        return children[i];
    }

    /**
     * @see Node
     */
    public int jjtGetNumChildren() {
        return (children == null) ? 0 : children.length;
    }

  /* You can override these two methods in subclasses of SimpleNode to
     customize the way the node appears when the tree is dumped.  If
     your output uses more than one line you should override
     toString(String), otherwise overriding toString() is probably all
     you need to do. */

    public String toString() { return JDCParserTreeConstants.jjtNodeName[id]; }
    public String toString(String prefix) { return prefix + toString(); }

  /* Override this method if you want to customize how the node dumps
     out its children. */
    public void dump(String prefix) {
        System.out.println(toString(prefix));
        if (children != null) {
            for (int i = 0; i < children.length; ++i) {
                SimpleNode n = (SimpleNode)children[i];
                if (n != null) {
                    n.dump(prefix + " ");
                }
            }
        }
    }

// Manually inserted code begins here
    /**
     * The tokens at the beginning and end of the node
     */
    protected Token begin, end;

    /**
     * The level to which this node should be indented
     */
    protected int indentationLevel;

    /**
     * Whether or not this node should affect the indentation level of its children
     */
    protected boolean indent = true;

    /**
     * Whether or not this is a JavaDecaf class
     */
    protected static boolean decafClass;

    /**
     * Whether or not this node is in a JavaDecaf main method
     */
    protected static boolean decafMain;

    /**
     * Sets the first token in the node to a particular token.
     * @param t the token to set as the first token.
     */
    public void setFirstToken(Token t) { begin = t; }

    /**
     * Sets the first token in the node to a particular token.
     * @param t the token to set as the last token.
     */
    public void setLastToken(Token t) { end = t; }

    /**
     * Processes the contents of the node. Set the node's indentation level, check whether it needs
     * indenting, then print its contents. Finally, process all the node's children.
     * @param ostr the output stream to print to.
     */
    public void process (PrintWriter ostr) {
        setIndentationLevel();
        Token t = begin;
        /*
            Indentation checking should only happen if the node is an Indentable node, and its parent is an IndentationContainer.
         */
        if (jjtGetParent() instanceof IndentationContainer && this instanceof Indentable) {
            NodeUtils.checkIndentation(parser, begin, this);
        }

        /* Indent any Indentable that requires indenting. */
        if (this instanceof Indentable) {
            NodeUtils.indent(t, this);
        }

        Token lastToken = null;
            if (this instanceof LastTokenEater && end != null) {
                lastToken = Token.newToken(0,end.image); //Assign value of end to lastToken before end is reassigned
            }


        /* If the node has children, set end token to first child's begin token.
        This prevents printing duplicate tokens.
         */
        if (jjtGetNumChildren() > 0) {
            end = ((SimpleNode)jjtGetChild(0)).begin;
        }

        /* Iterate through node's tokens and print them */
        while (t != null && t != end){
            /* Check for comments - prevent them being lost */
            if (NodeUtils.hasComment(t)){
                print(NodeUtils.getComment(t, this),ostr);
            }
            print(t, ostr);
            t = t.next;
        }

        /* Process all node children */
        SimpleNode child;
        for (int i = 0; i<jjtGetNumChildren(); i++) {
            child = (SimpleNode) jjtGetChild(i);
            child.process(ostr);

            if (i == 0) {
            /* Prevent loss of parenthesis in loop conditions - print it after the ConditionalExpression
            * but before the Block */
                if (this instanceof ConditionalSimpleNode)  {
                    ostr.print(")");
                }
            /* Prevent loss of parenthesis and opening brace in switch statements - print it after the ConditionalExpression
            * but before the Block */
                if (this instanceof ASTSwitchStatement) {
                    ostr.print(") {");
                }
            }
        }

        /* Print any missing last tokens */
        if (this instanceof LastTokenEater) {
            print(lastToken, ostr); //Manually print last token
        }
    }

    /**
     * Returns the node's indentation level
     * @return the indentation level
     */
    public int getIndentationLevel() {
        return indentationLevel;
    }

    /**
     * Sets the node's indentation level by iterating through parents
     */
    public void setIndentationLevel(){
        if (jjtGetParent() != null ) {
            indentationLevel = ((SimpleNode) jjtGetParent()).getIndentationLevel();
            if (indent) { //only increase indentation if not block or base
                indentationLevel += 1;

                if (jjtGetParent() instanceof ASTSwitchStatement
                        && (!(this instanceof ASTCaseSwitchLabel))
                        && (!(this instanceof ASTDefaultSwitchLabel))){
                    indentationLevel += 1;
                }
            }

        }

    }

    /**
     * Checks whether this node is in a JavaDecaf class.
     * @return true if this is a JavaDecaf class, otherwise false
     */
    public static boolean isDecafClass(){
        return decafClass;
    }

    /**
     * Checks whether this node is in a Decaf method.
     * @return true if this is a Decaf method, otherwise false
     */
    public static boolean isDecafMain() { return decafMain; }

    /**
     * Prints a token with all its preceding Special Tokens (white space and comments).
     * This method was already provided.
     * @param t - the token to print
     * @param ostr - the PrintWriter to print to
     */
    protected void print(Token t, PrintWriter ostr) {
        Token tt = t.specialToken;
        if (tt != null) {
            while (tt.specialToken != null) tt = tt.specialToken;
            while (tt != null) {
                ostr.print(addUnicodeEscapes(tt.image));
                tt = tt.next;
            }
        }
        ostr.print(addUnicodeEscapes(t.image));
    }

    /**
     * Escapes any special characters.
     * @param str - The string to escape
     * @return the escaped sequence as a String
     */
    private String addUnicodeEscapes(String str) {
        String retval = "";
        char ch;
        for (int i = 0; i < str.length(); i++) {
            ch = str.charAt(i);
            if ((ch < 0x20 || ch > 0x7e) && ch != '\t' && ch != '\n' && ch != '\r' && ch != '\f') {
                String s = "0000" + Integer.toString(ch, 16);
                retval += "\\u" + s.substring(s.length() - 4, s.length());
            } else {
                retval += ch;
            }
        }
        return retval;
    }
}

